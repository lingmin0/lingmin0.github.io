[{"title":"Leetcode 24","url":"/2019/01/16/Leetcode-24/","content":"\n\n\n## LeetCode 24.Swap Nodes in Pairs\n\n### 题目\n\nGiven a linked list, swap every two adjacent nodes and return its head.\n\n#### Example\n\n```\nGiven 1->2->3->4, you should return the list as 2->1->4->3.\n```\n\n#### Note:\n\n- Your algorithm should use only constant extra space.\n- You may **not** modify the values in the list's nodes, only nodes itself may be changed.\n\n------\n\n### 解题思路：\n\n以Example为例：\n\n![](/Users/ling/Documents/lmblog/source/_posts/Leetcode24.jpg)\n\n### JAVA代码\n\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next==null  )\n            return head;\n        ListNode temp1=head.next;\n        head.next=temp1.next;\n        temp1.next=head;\n        head=temp1;\n        temp1=head.next;\n        while(temp1.next!=null && temp1.next.next!=null){\n            ListNode temp2=temp1.next;\n            temp1.next=temp2.next;\n            temp2.next=temp1.next.next;\n            temp1.next.next=temp2;\n            temp1=temp2;\n        }\n        return head;\n    }\n}\n```\n\n"},{"title":"Leetcode 707","url":"/2019/01/16/Leetcode 707.Design Linked List/","content":"\n## Leetcode 707.Design Linked List\n\n### 题目：\n\nDesign your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should have two attributes: `val` and `next`. `val` is the value of the current node, and `next` is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute `prev` to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.\n\nImplement these functions in your linked list class:\n\n- get(index) : Get the value of the `index`-th node in the linked list. If the index is invalid, return `-1`.\n- addAtHead(val) : Add a node of value `val` before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\n- addAtTail(val) : Append a node of value `val` to the last element of the linked list.\n- addAtIndex(index, val) : Add a node of value `val` before the `index`-th node in the linked list. If `index` equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.\n- deleteAtIndex(index) : Delete the `index`-th node in the linked list, if the index is valid.\n\n#### Example:\n\n```\nMyLinkedList linkedList = new MyLinkedList();\nlinkedList.addAtHead(1);\nlinkedList.addAtTail(3);\nlinkedList.addAtIndex(1, 2);  // linked list becomes 1->2->3\nlinkedList.get(1);            // returns 2\nlinkedList.deleteAtIndex(1);  // now the linked list is 1->3\nlinkedList.get(1);            // returns \n```\n\n#### Note:\n\n- All values will be in the range of `[1, 1000]`.\n\n- The number of operations will be in the range of `[1, 1000]`.\n\n- Please do not use the built-in LinkedList library.\n\n  \n\n### 解题思路：\n\n此题设计一个链表，熟悉链表的插入、删除操作；\n\n- get(index) : 考虑index越界的情况\n\n- addAtHead(val) : 方法需要考虑如果链表为空的情况\n\n- addAtTail(val) : 方法需要考虑如果链表为空的情况\n\n- addAtIndex(index, val) :a.index=0 调用addAtHead(val)方法；b.index=length 调用addAtTail(val)方法;c.index>0&&index<length;\n\n  \n\n- deleteAtIndex(index) : 考虑当index=0,length=1的情况，执行方法后，链表为空\n\n### 代码-JAVA\n\n```\nclass MyLinkedList {\n    class Node{\n        int val;\n        Node next;\n        public Node(){}\n        public Node(int n){\n            val=n;\n        }\n    }\n    //head始终为空节点\n    Node head=null;\n    int length=0;\n    /** Initialize your data structure here. */\n    public MyLinkedList() {\n        head = new Node();\n        length=0;\n    }\n    \n    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\n    public int get(int index) {\n        if(index>=length || index<0){return -1;}\n        Node t=head;\n        for(int i=0;i<=index;i++){\n            t=t.next;\n        }\n        return t.val;\n    }\n    \n    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\n    public void addAtHead(int val) {\n        Node t=new Node(val);\n        if(head.next==null){head.next=t;}\n        else{\n            t.next=head.next;\n            head.next=t;\n        }\n        length++;\n    }\n    \n    /** Append a node of value val to the last element of the linked list. */\n    public void addAtTail(int val) {\n        Node t=new Node(val);\n        if(head.next==null){head.next=t;}\n        else{\n            Node temp=head;\n            while(temp.next!=null){\n                temp=temp.next;\n            }\n            temp.next=t;\n        }\n        length++;\n    }\n    \n    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\n    public void addAtIndex(int index, int val) {\n        if(index==length){addAtTail(val);}\n        else if(index==0) {addAtHead(val);}\n        else if(index<length && index>0){\n            Node t=new Node(val);\n            Node temp=head;\n            for(int i=0;i<index;i++)\n                temp=temp.next;\n            t.next=temp.next;\n            temp.next=t;\n            length++;\n        }\n    }\n    \n    /** Delete the index-th node in the linked list, if the index is valid. */\n    public void deleteAtIndex(int index) {\n        if(index==0){\n            if(length==1){head=null;}\n            else{\n                head.next=head.next.next;\n            }\n            length--;\n        }\n        else if(index<length && index>0){\n            Node temp=head;\n            for(int i=0;i<index;i++)\n                temp=temp.next;\n            if(index==length-1){temp.next=null;}\n            else{\n                temp.next=temp.next.next;\n            }\n            length--;\n        }\n        \n    }\n}\n```\n\n"},{"title":"LeetCode 109","url":"/2018/07/13/Leetcode 109.Convert Sorted List to Binary Search Tree/","content":"\n\n\n### Leetcode 109.Convert Sorted List to Binary Search Tree\n\n#### 题目描述\n\nGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.\n\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of *every* node never differ by more than 1.\n\n（给定单个链接列表，其中元素按升序排序，将其转换为高度平衡的BST。对于这个问题，高度平衡的二叉树被定义为二叉树，其中每个节点的两个子树的深度从不相差超过1。）\n\n#### 样例\n\n```\nGiven the sorted linked list: [-10,-3,0,5,9],\n\nOne possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n```\n\n#### 解题思路\n\n构造高度平衡的二叉树，很容易想到利用二分法递归构造二叉树，链表的二分常用快慢指针实现。\n\nps:这里未了保证链表的序列不被破坏，利用tail标志标名链表的末位置\n\n例如：\n\n1->2->3->4->5->6->7->tail\n\n第一次二分：（左边初位置lh)1->2->3->4(为左边结束位置lt，可理解为1->2->3->NULL)\n\n​\t\t\t  (右边初位置rh)5->6->7->tail(为右边结束位置rt)\n\n​\t\t\t  生成树根节点4\n\n依次类推，增加标志位，避免改变链表原来的顺序\n\n#### 代码\n\n```\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        return sortedListToBST(head,NULL);     \n    }\nprivate:\n    TreeNode* sortedListToBST(ListNode* head,ListNode* tail){\n        if(head==tail || head->next==tail){  //\n            return head==tail ? NULL : new TreeNode(head->val) ;\n        }\n        \n        ListNode* slow=head;\n        ListNode* fast=head->next;\n        \n        while(fast->next!=tail && fast->next->next!=tail){\n            slow=slow->next;\n            fast=fast->next->next;\n        }\n        //通过快慢指针找到左边序列的结束标志和右边序列的起始标志\n        ListNode *lh=head , *lt=slow->next , *med=slow->next;\n        ListNode *rh=med->next , *rt=tail;\n        \n        \n        TreeNode *root = new TreeNode(med->val);//\n        root->left = sortedListToBST(lh,lt);//左递归\n        root->right= sortedListToBST(rh,rt);//右递归\n        \n        return root;\n    }\n};\n```\n\n#### 知识点总结\n\n1. 利用递归思想构造二叉树\n2. 快慢指针实现二分\n3. **增加标志位tail,避免原链表被破坏**\n\n说明：参考博客https://blog.csdn.net/makuiyu/article/details/45099025"},{"title":"ARIMA模型","url":"/2018/07/11/ARIMA模型/","content":"\n\n\n### ARIMA模型\n\n#### 数据平稳性与差分法\n\n##### 平稳性\n\n- 平稳性要求经由样本时间序列所得到的拟合曲线在未来的一段期间内仍能顺着现有的形态“惯性地延续下去”\n\n- 平稳性要求序列的均值和方差不发生明显的变化\n\n  \n\n##### 严平稳和若平稳\n\n- 严平稳：表示的分布不随时间的改变而改变。如：白噪声（正态），无论怎么取，期望为0，方差为1\n- 若平稳：期望与相关系数（依赖性）不变。未来某时刻的t的值Xt就要依赖于它的过去信息，所以需要依赖性\n\n\n\n##### 如何处理数据使其平稳？？\n\n差分法：\n\n- 一阶差分：时间序列t与t-1时刻的差值（通常使用一阶足够）\n\n- 二阶差分：时间序列t与t-1时刻的差值减去t-1与t-2时刻的差值\n\n  \n\n#### ARIMA模型\n\n##### 自回归模型（AR）\n\n- 描述当前值与历史值之间的关系，用变量自身的历史数据对自身进行预测\n\n- 自回归模型必须满足平稳性的要求\n\n- p阶自回归过程的公式定义：\n  $$\n  {y}_{t}=\\mu +\\sum_{i=1}^{p}{y}_{i}{y}_{t-i}+{\\epsilon}_{t}  ；\n  {y}_{t}是当前值，\\mu是常数项，p是阶数，{y}_{i}是自相关系数，{\\epsilon}_{t}  是误差\n  $$\n  \n\n##### 自回归模型的限制\n\n自回归模型是用自身的数据来进行预测\n\n- 必须具有平稳性\n\n- 必须具有自相关性，如果自相关系数小于0.5，则不宜采用\n\n- 自回归只适用于预测与自身前期相关的现象\n\n  \n\n##### 移动平均模型（MA）\n\n- 移动平均模型关注的是自回归模型中误差项的累加\n\n- q阶自回归过程的公式定义：\n  $$\n  {y}_{t}=\\mu +{\\epsilon}_{t}+\\sum_{i=1}^{q}{\\theta}_{i}{\\epsilon}_{t-i}+{\\epsilon}_{t}  ；\n  {y}_{t}是当前值，\\mu是常数项，q是阶数,{\\theta}_{i}是系数，{\\epsilon}_{t}  是误差\n  $$\n  移动平均法能有效地消除预测中的随机波动\n\n  \n\n##### 自回归移动平均模型（ARMA）\n\n- 自回归与移动平均的结合\n\n- 公式定义\n  $$\n  {y}_{t}=\\mu +\\sum_{i=1}^{p}{y}_{i}{y}_{t-i}+{\\epsilon}_{t}  +\\sum_{i=1}^{q}{\\theta}_{i}{\\epsilon}_{t-i} ；\n  $$\n  \n\n##### ARIMA（p,d,q）模型：差分自回归移动平均模型\n\n1. AR是自回归，p为自回归项；\n2. MA为移动平均，q为移动平均项数\n3. d为时间序列成为平稳时所做的差分次数\n4. 原理：将非平稳时间序列转化为平稳时间序列然后将因变量仅对它的滞后值以及随机误差项的现值和滞后值进行回归所建立的模型\n\n\n\n#### 相关函数评估方法\n\n##### 自相关函数ACF\n\n- 有序的随机变量序列与其自身相比较自相关函数反映了同一序列在不同时序的取值之间的相关性\n\n- 公式：\n  $$\n  ACF（k)={p}_{k}={\\frac{Cov({y}_{t},{y}_{t-k})}{Var({y}_{t})}}\n  $$\n  Pk的取值范围为[-1,1]\n\n##### 偏自相关函数（PACF）\n\n- 对于一个平稳AR(p)模型，求出滞后k自相关系数p(k)时实际上得到并不是x(t)与x(t-k)之间单纯的相关关系\n- x(t)同时还会受到中间k-1个随机变量的影响，而这k-1个随机变量又和x(t-k)具有相关关系，所以自相关系数p(k)里实际掺杂了其他变量对x(t)与x(t-k)的影响\n- 剔除了中间k-1个随机变量x(t-1)、x(t-2)、……、x(t-k+1)的干扰之后x(t-k)对x(t)影响的相关程度\n- ACF还包含了其他变量的影响，而PACF是严格这两个变量之间的相关性\n\n\n\n##### ARIMA(p,d,q)阶数确定\n\n| 模型      | ACF                              | PACF                             |\n| --------- | -------------------------------- | -------------------------------- |\n| AR(p)     | 衰减趋于0（几何型或震荡型）      | **<u>p阶后截尾</u>**             |\n| MA(q)     | <u>**q阶后截尾**</u>             | 衰减趋于0（几何型或震荡型）      |\n| ARMA(p,q) | q阶后衰减趋于0（几何型或震荡型） | p阶后衰减趋于0（几何型或震荡型） |\n\n截尾：落在置信区间内（95%的点都符合该规则）\n\n\n\n#### ARIMA建模流程\n\n1. 将序列平稳（差分法确定d）\n2. p和q阶数确定：ACF和PACF\n3. ARIMA（p,d,q）\n\n\n\n这里对ARIMA模型进行简单的解释和说明，具体参考：https://www.bilibili.com/video/av26089067"},{"title":"Leetcode 148","url":"/2018/07/07/Leetcode 328.Odd Even Linked List/","content":"\n### Leetcode 328.Odd Even Linked List\n\n#### 题目描述\n\nGiven a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\n\nYou should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\n\n**Example 1:**\n\n```\nInput: 1->2->3->4->5->NULL\nOutput: 1->3->5->2->4->NULL\n```\n\n**Example 2:**\n\n```\nInput: 2->1->3->5->6->4->7->NULL\nOutput: 2->3->6->7->1->5->4->NULL\n```\n\n**Note:**\n\n- The relative order inside both the even and odd groups should remain as it was in the input.\n- The first node is considered odd, the second node even and so on ...\n\n#### 解题思路\n\n此题同样考虑时间复杂度和空间复杂度\n\n利用“奇偶”指针的思路，把list分为变成奇list和偶list（奇偶表示原list每个元素的下标，从1开始）\n\n一遍扫描得到两个list，将两个list合并即可\n\n\n\n#### 代码\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* oddEvenList(ListNode* head) {\n        if(head==NULL || head->next==NULL) return head;//考虑特殊情况\n        ListNode* head1=head;\n        ListNode* head2=head->next;\n        ListNode* t1=head1;\n        ListNode* t2=head2;\n        while(head1->next->next!=NULL && head2->next->next!=NULL){ \n            head1->next = head1->next->next;\n            head2->next = head2->next->next;\n            head1 = head1->next;\n            head2 = head2->next;\n        }\n        if(head2->next!=NULL){  //如果list表长度为奇数\n            head1->next=head2->next;\n            head1=head1->next;\n            head2->next=NULL;\n        }\n        head1->next = t2;\n        return t1;\n    }\n};\n```\n\n"},{"title":"Leetcode 148","url":"/2018/07/07/Leetcode 148.Sort List/","content":"\n\n### Leetcode 148.Sort List\n\n#### 题目描述\n\nSort a linked list in *O*(*n* log *n*) time using constant space complexity.\n\n**Example 1:**\n\n```\nInput: 4->2->1->3\nOutput: 1->2->3->4\n```\n\n**Example 2:**\n\n```\nInput: -1->5->3->4->0\nOutput: -1->0->3->4->5\n```\n\n#### 解题思路\n\n这里要求对时间复杂度为*O*(*n* log *n*) ，空间复杂度为常数\n\n这里采用合并排序，递归实现合并排序（递归代码较为简洁）\n\n参考：\n\n[1]: https://blog.csdn.net/geekmanong/article/details/50451339\t\" \"\n\n\n\n#### 代码\n\n```\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n         if (head == NULL || head->next == NULL)  return head;\n        ListNode* slow=head;\n        ListNode* fast=head;\n        while(fast->next!=NULL && fast->next->next!=NULL){ //利用快慢指针实现分割\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        //链表断开\n        fast=slow;\n        slow=slow->next;\n        fast->next=NULL;\n        ListNode* l1=sortList(head);\n        ListNode* l2=sortList(slow);\n        return mergeList(l1,l2);\n    }\n    \n    ListNode* mergeList(ListNode* l1,ListNode*l2){\n        ListNode* temp=new ListNode(0);\n        ListNode* temp1=temp;\n        while(l1!=NULL && l2!=NULL){\n            if(l1->val<= l2->val){\n                temp->next=l1;\n                l1 = l1->next;\n            }\n            else{\n                temp->next = l2;\n                l2 = l2->next;\n            }\n            temp=temp->next;\n        }\n        temp->next = (l1==NULL)?l2:l1  ;\n        return temp1->next;\n    }\n };\n```\n\n#### 心得\n\n此题对时间和空间复杂度有一定的要求，因此我们需要想到满足时空复杂度的算法，同时对递归的思想应该有所理解和掌握。"},{"title":"Leetcode 147","url":"/2018/07/07/Leetcode 147.Insertion Sort List/","content":" \n## Leetcode 147.Insertion Sort List\n\n### 题目：\n\nSort a linked list using insertion sort.\n\n\n![img](https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif)\nA graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.\nWith each iteration one element (red) is removed from the input data and inserted in-place into the sorted list\n\n\n**Algorithm of Insertion Sort:**\n\n1. Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.\n2. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.\n3. It repeats until no input elements remain.\n\n**Example 1:**\n\n```\nInput: 4->2->1->3\nOutput: 1->2->3->4\n```\n\n**Example 2:**\n\n```\nInput: -1->5->3->4->0\nOutput: -1->0->3->4->5\n```\n\n### 解题思路\n\n1. 如果list长度为0或为1，return\n\n2. 如果list长度大于1\n\n   将list分为两部分，分别向左和右延伸，设定两个头指针，head和newhead，如题head：5->3->1->8->7->2->4 ,newehead:6->NULL ；找到newhead中head对应指针应该插入的位置，head设定为head->next\n\n   直到处理完原指针的末位置，最后将list倒置；\n\n   例如：4->2->1->3\n\n   1. NULL<\\-4         2->1->3->NULL\n\n   2. NULL<\\-2<\\-4    1->3->NULL\n\n   3. NULL<-1<\\-2<\\-4    3->NULL\n\n   4. NULL<-1<\\-2<-3<\\-4  NULL\n\n   5. 转置\n\n      \n\n      ### 代码\n\n      ```\n      /**\n       * Definition for singly-linked list.\n       * struct ListNode {\n       *     int val;\n       *     ListNode *next;\n       *     ListNode(int x) : val(x), next(NULL) {}\n       * };\n       */\n      class Solution {\n      public:\n          ListNode* insertionSortList(ListNode* head) {\n              if(head==NULL ||head->next==NULL)\n                  return head;\n              ListNode* newhead=head;\n              head=head->next;\n              newhead->next=NULL;\n              while(head!=NULL){\n                  if(head->val < newhead->val){//找到head应该插入的位置，这里采用两个临时指针\n                      ListNode* temp1=newhead;\n                      ListNode* temp2=newhead->next;\n                      while(temp2!=NULL){\n                          if(temp1->val > head->val && temp2->val <= head->val )  break;\n                          else{\n                              temp1 = temp2;\n                              temp2 = temp2->next;\n                          }\n                      }\n                      ListNode* temp3=head;\n                      head=head->next;\n                      temp1->next=temp3;\n                      if(temp2==NULL)\n                          temp3->next=NULL;    \n                      else\n                          temp3->next=temp2; \n                  }\n                  else{\n                      ListNode* temp3=head;\n                      head=head->next;\n                      temp3->next=newhead;\n                      newhead = temp3;\n                  }\n              }\n              /*转置*/\n              ListNode* newhead1=newhead->next;\n              newhead->next=NULL;\n              while(newhead1!=NULL){\n                  ListNode* newhead2=newhead1->next;\n                  newhead1->next=newhead;\n                  newhead=newhead1;\n                  newhead1=newhead2;\n              }\n              return newhead;\n          }\n      };\n      ```\n\n      \n\n   ### 心得\n\n   非常简单的实现指针排序的一个算法，主要掌握指针的用法"},{"title":"数据库实验JDBC","url":"/2018/06/14/数据库实验8/","content":"\n\n## 实验代码\n\n\n\n```java\nimport java.sql.*;\nimport java.util.Scanner;\npublic class myodbc {\n    public static Statement stmt=null;\n\n    static final String JDBC_DRIVER=\"com.mysql.jdbc.Driver\";//驱动\n    static final String DB_URL=\"jdbc:mysql://localhost:3306/course\";//URL 服务器localhost，端口号3306，数据库course\n\n    static final String USER=\"root\";//用户\n    static final String PASS=\"2712172\";//密码\n\n    public static void add_student(String sno,String sname,String ssex,String sage,String sdept){   //在student表中添加用户信息\n        try{\n            String a = \"INSERT INTO Student \" +\"VALUES ('\"+sno+\"','\"+ sname+\"','\"+ssex+\"',\"+sage+\",'\"+sdept+\"');\";\n            stmt.executeUpdate(a);\n            System.out.println(\"add su1ccess!\");\n        }\n        catch(SQLException se){se.printStackTrace();}\n    }\n\n    public static void print_Student(ResultSet rs){\n        try{\n\n            System.out.println(\"+Sno+-----+Sname+-----+Ssex+-----+Sage+-----+Sdept+\");\n            while(rs.next()){\n                String Sno  = rs.getString(\"Sno\");\n                String Sname = rs.getString(\"Sname\");\n                String Ssex = rs.getString(\"Ssex\");\n                String Sage= rs.getString(\"Sage\");\n                String Sdept=rs.getString(\"Sdept\");\n                System.out.println(Sno +\",     \"+Sname+\",     \"+Ssex+\",     \"+Sage+\",     \"+Sdept);\n            }\n            System.out.println(\" \");\n        }catch(SQLException se){se.printStackTrace();}\n    }\n\n    public static void update_student(String Sno,String column,String a){   //更新列属性年龄或者系\n        try{\n            String temp=\"111111\";//初始化\n            if(column.equals(\"Sage\")){//更新属性年龄\n                temp = \"UPDATE Student SET \"+column +\"=\"+a+\" where Sno='\"+Sno+\"'\";\n            }\n            else if(column.equals(\"Sdept\")) {//更新属性Sdept\n                temp = \"UPDATE Student SET \" + column + \"='\" + a + \"' where Sno='\" + Sno + \"'\";\n            }\n            stmt.executeUpdate(temp);\n            System.out.println(\"update success!\");\n        }\n        catch(SQLException se){se.printStackTrace();}\n    }\n\n    public static void delete_student(String Sno){   //学生学号\n        try{\n            String temp = \"DELETE FROM Student where Sno='\"+Sno+\"'\";//SQL语句\n            stmt.executeUpdate(temp);\n            System.out.println(\"delete success!\");\n        }\n        catch(SQLException se){se.printStackTrace();}\n    }\n\n\n    public static void main(String[] args) {\n        Connection conn = null;\n        try {\n            Scanner scanner = new Scanner(System.in);//输入流\n\n            Class.forName(\"com.mysql.jdbc.Driver\");//加载驱动\n            conn = DriverManager.getConnection(DB_URL, USER, PASS);//创建连接\n            stmt = conn.createStatement();//\n\n            while(true){//循环操作\n                System.out.println(\"查询请按0--插入请按1--更新请按2--删除请按3\");\n                int flags= Integer.parseInt(scanner.nextLine());\n                if(flags==0){                           //查询信息\n                    String sql=\"select * from Student;\";\n                    ResultSet rs= stmt.executeQuery(sql);\n                    print_Student(rs);\n                }\n                else if(flags==1){//表示插入        //插入操作\n                    System.out.println(\"请输入：Sno Sname Ssex Sage Sdept\");\n                    String nextLine = scanner.nextLine();//读入一行\n                    String[] str;\n                    str = nextLine.split(\",\");//用，作为分割\n                    add_student(str[0],str[1],str[2],str[3],str[4]);\n                }\n                else if(flags==2){//表示更新\n                    System.out.println(\"请输入更改的学生学号：Sno，更新内容属性-值：colunmn value\");\n                    String nextLine = scanner.nextLine();//读入一行\n                    String[] str;\n                    str = nextLine.split(\",\");//用，作为分割\n                    update_student(str[0],str[1],str[2]);\n                }\n                else if(flags==3){//表示删除\n                    System.out.println(\"请输入要删除的学生学号：Sno\");\n                    String Sno= scanner.nextLine();\n                    delete_student(Sno);\n                }\n                else\n                    break;\n            }\n            conn.close();//关闭连接\n        }catch(SQLException se){se.printStackTrace();}\n        catch(Exception e){e.printStackTrace();}\n        finally{\n            try{if(stmt!=null)stmt.close();}\n            catch(SQLException se2){ }// nothing we can do\n            try{\n                if(conn!=null)\n                    conn.close();//关闭连接\n            }catch(SQLException se){ se.printStackTrace();}//end finally try\n        }//end try\n    }\n}\n\n```\n\n\n"}]