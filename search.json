[{"url":"/2018/07/07/Leetcode 328.Odd Even Linked List/","content":"### Leetcode 328.Odd Even Linked List\n\n#### 题目描述\n\nGiven a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\n\nYou should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\n\n**Example 1:**\n\n```\nInput: 1->2->3->4->5->NULL\nOutput: 1->3->5->2->4->NULL\n```\n\n**Example 2:**\n\n```\nInput: 2->1->3->5->6->4->7->NULL\nOutput: 2->3->6->7->1->5->4->NULL\n```\n\n**Note:**\n\n- The relative order inside both the even and odd groups should remain as it was in the input.\n- The first node is considered odd, the second node even and so on ...\n\n#### 解题思路\n\n此题同样考虑时间复杂度和空间复杂度\n\n利用“奇偶”指针的思路，把list分为变成奇list和偶list（奇偶表示原list每个元素的下标，从1开始）\n\n一遍扫描得到两个list，将两个list合并即可\n\n\n\n#### 代码\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* oddEvenList(ListNode* head) {\n        if(head==NULL || head->next==NULL) return head;//考虑特殊情况\n        ListNode* head1=head;\n        ListNode* head2=head->next;\n        ListNode* t1=head1;\n        ListNode* t2=head2;\n        while(head1->next->next!=NULL && head2->next->next!=NULL){ \n            head1->next = head1->next->next;\n            head2->next = head2->next->next;\n            head1 = head1->next;\n            head2 = head2->next;\n        }\n        if(head2->next!=NULL){  //如果list表长度为奇数\n            head1->next=head2->next;\n            head1=head1->next;\n            head2->next=NULL;\n        }\n        head1->next = t2;\n        return t1;\n    }\n};\n```\n\n"},{"url":"/2018/07/07/Leetcode 148.Sort List/","content":"### Leetcode 148.Sort List\n\n#### 题目描述\n\nSort a linked list in *O*(*n* log *n*) time using constant space complexity.\n\n**Example 1:**\n\n```\nInput: 4->2->1->3\nOutput: 1->2->3->4\n```\n\n**Example 2:**\n\n```\nInput: -1->5->3->4->0\nOutput: -1->0->3->4->5\n```\n\n#### 解题思路\n\n这里要求对时间复杂度为*O*(*n* log *n*) ，空间复杂度为常数\n\n这里采用合并排序，递归实现合并排序（递归代码较为简洁）\n\n参考：\n\n[1]: https://blog.csdn.net/geekmanong/article/details/50451339\t\" \"\n\n\n\n#### 代码\n\n```\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n         if (head == NULL || head->next == NULL)  return head;\n        ListNode* slow=head;\n        ListNode* fast=head;\n        while(fast->next!=NULL && fast->next->next!=NULL){ //利用快慢指针实现分割\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        //链表断开\n        fast=slow;\n        slow=slow->next;\n        fast->next=NULL;\n        ListNode* l1=sortList(head);\n        ListNode* l2=sortList(slow);\n        return mergeList(l1,l2);\n    }\n    \n    ListNode* mergeList(ListNode* l1,ListNode*l2){\n        ListNode* temp=new ListNode(0);\n        ListNode* temp1=temp;\n        while(l1!=NULL && l2!=NULL){\n            if(l1->val<= l2->val){\n                temp->next=l1;\n                l1 = l1->next;\n            }\n            else{\n                temp->next = l2;\n                l2 = l2->next;\n            }\n            temp=temp->next;\n        }\n        temp->next = (l1==NULL)?l2:l1  ;\n        return temp1->next;\n    }\n };\n```\n\n#### 心得\n\n此题对时间和空间复杂度有一定的要求，因此我们需要想到满足时空复杂度的算法，同时对递归的思想应该有所理解和掌握。"},{"url":"/2018/07/07/Leetcode 147.Insertion Sort List/","content":"## Leetcode 147.Insertion Sort List\n\n### 题目：\n\nSort a linked list using insertion sort.\n\n\n![img](https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif)\nA graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.\nWith each iteration one element (red) is removed from the input data and inserted in-place into the sorted list\n\n\n**Algorithm of Insertion Sort:**\n\n1. Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.\n2. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.\n3. It repeats until no input elements remain.\n\n**Example 1:**\n\n```\nInput: 4->2->1->3\nOutput: 1->2->3->4\n```\n\n**Example 2:**\n\n```\nInput: -1->5->3->4->0\nOutput: -1->0->3->4->5\n```\n\n### 解题思路\n\n1. 如果list长度为0或为1，return\n\n2. 如果list长度大于1\n\n   将list分为两部分，分别向左和右延伸，设定两个头指针，head和newhead，如题head：5->3->1->8->7->2->4 ,newehead:6->NULL ；找到newhead中head对应指针应该插入的位置，head设定为head->next\n\n   直到处理完原指针的末位置，最后将list倒置；\n\n   例如：4->2->1->3\n\n   1. NULL<\\-4         2->1->3->NULL\n\n   2. NULL<\\-2<\\-4    1->3->NULL\n\n   3. NULL<-1<\\-2<\\-4    3->NULL\n\n   4. NULL<-1<\\-2<-3<\\-4  NULL\n\n   5. 转置\n\n      \n\n      ### 代码\n\n      ```\n      /**\n       * Definition for singly-linked list.\n       * struct ListNode {\n       *     int val;\n       *     ListNode *next;\n       *     ListNode(int x) : val(x), next(NULL) {}\n       * };\n       */\n      class Solution {\n      public:\n          ListNode* insertionSortList(ListNode* head) {\n              if(head==NULL ||head->next==NULL)\n                  return head;\n              ListNode* newhead=head;\n              head=head->next;\n              newhead->next=NULL;\n              while(head!=NULL){\n                  if(head->val < newhead->val){//找到head应该插入的位置，这里采用两个临时指针\n                      ListNode* temp1=newhead;\n                      ListNode* temp2=newhead->next;\n                      while(temp2!=NULL){\n                          if(temp1->val > head->val && temp2->val <= head->val )  break;\n                          else{\n                              temp1 = temp2;\n                              temp2 = temp2->next;\n                          }\n                      }\n                      ListNode* temp3=head;\n                      head=head->next;\n                      temp1->next=temp3;\n                      if(temp2==NULL)\n                          temp3->next=NULL;    \n                      else\n                          temp3->next=temp2; \n                  }\n                  else{\n                      ListNode* temp3=head;\n                      head=head->next;\n                      temp3->next=newhead;\n                      newhead = temp3;\n                  }\n              }\n              /*转置*/\n              ListNode* newhead1=newhead->next;\n              newhead->next=NULL;\n              while(newhead1!=NULL){\n                  ListNode* newhead2=newhead1->next;\n                  newhead1->next=newhead;\n                  newhead=newhead1;\n                  newhead1=newhead2;\n              }\n              return newhead;\n          }\n      };\n      ```\n\n      \n\n   ### 心得\n\n   非常简单的实现指针排序的一个算法，主要掌握指针的用法"},{"title":"数据库实验JDBC","url":"/2018/06/14/数据库实验8/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## 实验代码\n\n\n\n```java\nimport java.sql.*;\nimport java.util.Scanner;\npublic class myodbc {\n    public static Statement stmt=null;\n\n    static final String JDBC_DRIVER=\"com.mysql.jdbc.Driver\";//驱动\n    static final String DB_URL=\"jdbc:mysql://localhost:3306/course\";//URL 服务器localhost，端口号3306，数据库course\n\n    static final String USER=\"root\";//用户\n    static final String PASS=\"2712172\";//密码\n\n    public static void add_student(String sno,String sname,String ssex,String sage,String sdept){   //在student表中添加用户信息\n        try{\n            String a = \"INSERT INTO Student \" +\"VALUES ('\"+sno+\"','\"+ sname+\"','\"+ssex+\"',\"+sage+\",'\"+sdept+\"');\";\n            stmt.executeUpdate(a);\n            System.out.println(\"add su1ccess!\");\n        }\n        catch(SQLException se){se.printStackTrace();}\n    }\n\n    public static void print_Student(ResultSet rs){\n        try{\n\n            System.out.println(\"+Sno+-----+Sname+-----+Ssex+-----+Sage+-----+Sdept+\");\n            while(rs.next()){\n                String Sno  = rs.getString(\"Sno\");\n                String Sname = rs.getString(\"Sname\");\n                String Ssex = rs.getString(\"Ssex\");\n                String Sage= rs.getString(\"Sage\");\n                String Sdept=rs.getString(\"Sdept\");\n                System.out.println(Sno +\",     \"+Sname+\",     \"+Ssex+\",     \"+Sage+\",     \"+Sdept);\n            }\n            System.out.println(\" \");\n        }catch(SQLException se){se.printStackTrace();}\n    }\n\n    public static void update_student(String Sno,String column,String a){   //更新列属性年龄或者系\n        try{\n            String temp=\"111111\";//初始化\n            if(column.equals(\"Sage\")){//更新属性年龄\n                temp = \"UPDATE Student SET \"+column +\"=\"+a+\" where Sno='\"+Sno+\"'\";\n            }\n            else if(column.equals(\"Sdept\")) {//更新属性Sdept\n                temp = \"UPDATE Student SET \" + column + \"='\" + a + \"' where Sno='\" + Sno + \"'\";\n            }\n            stmt.executeUpdate(temp);\n            System.out.println(\"update success!\");\n        }\n        catch(SQLException se){se.printStackTrace();}\n    }\n\n    public static void delete_student(String Sno){   //学生学号\n        try{\n            String temp = \"DELETE FROM Student where Sno='\"+Sno+\"'\";//SQL语句\n            stmt.executeUpdate(temp);\n            System.out.println(\"delete success!\");\n        }\n        catch(SQLException se){se.printStackTrace();}\n    }\n\n\n    public static void main(String[] args) {\n        Connection conn = null;\n        try {\n            Scanner scanner = new Scanner(System.in);//输入流\n\n            Class.forName(\"com.mysql.jdbc.Driver\");//加载驱动\n            conn = DriverManager.getConnection(DB_URL, USER, PASS);//创建连接\n            stmt = conn.createStatement();//\n\n            while(true){//循环操作\n                System.out.println(\"查询请按0--插入请按1--更新请按2--删除请按3\");\n                int flags= Integer.parseInt(scanner.nextLine());\n                if(flags==0){                           //查询信息\n                    String sql=\"select * from Student;\";\n                    ResultSet rs= stmt.executeQuery(sql);\n                    print_Student(rs);\n                }\n                else if(flags==1){//表示插入        //插入操作\n                    System.out.println(\"请输入：Sno Sname Ssex Sage Sdept\");\n                    String nextLine = scanner.nextLine();//读入一行\n                    String[] str;\n                    str = nextLine.split(\",\");//用，作为分割\n                    add_student(str[0],str[1],str[2],str[3],str[4]);\n                }\n                else if(flags==2){//表示更新\n                    System.out.println(\"请输入更改的学生学号：Sno，更新内容属性-值：colunmn value\");\n                    String nextLine = scanner.nextLine();//读入一行\n                    String[] str;\n                    str = nextLine.split(\",\");//用，作为分割\n                    update_student(str[0],str[1],str[2]);\n                }\n                else if(flags==3){//表示删除\n                    System.out.println(\"请输入要删除的学生学号：Sno\");\n                    String Sno= scanner.nextLine();\n                    delete_student(Sno);\n                }\n                else\n                    break;\n            }\n            conn.close();//关闭连接\n        }catch(SQLException se){se.printStackTrace();}\n        catch(Exception e){e.printStackTrace();}\n        finally{\n            try{if(stmt!=null)stmt.close();}\n            catch(SQLException se2){ }// nothing we can do\n            try{\n                if(conn!=null)\n                    conn.close();//关闭连接\n            }catch(SQLException se){ se.printStackTrace();}//end finally try\n        }//end try\n    }\n}\n\n```\n\n\n"}]